
var _ = _ || require('underscore');
var fs = exports && require('fs');
exports = exports || {};

function Control(name, type, id, bcl)
{
    this.name = name;
    this.type = type;
    this.id = id;
    this.bcl = bcl;
    var control = this;
    _.each(bcl,
           function (bclLine) {
               bclLine.replace(/ NRPN \d+ (\d+)/,
                               function (match, nrpn) {
                                   control.nrpn = parseInt(nrpn);
                               })
           });
}

exports.Control = Control;

function parseBCL(string)
{
    var retval = { originalString: string,
                   temporaryPreset: { controls: {} },
                   presets: [] };

    function parseControl (command, chunk) {
        if (command.replace(/^\$(encoder|button) +([0-9]+) *(|;.*)$/,
                            function (match, type, id, name) {
                                name = name.replace(/; */, "");
                                retval.temporaryPreset.controls[type + id] = new Control(name, type, id, chunk);
                            }) == command) {
            console.log('error parsing "' + command + '"');
        }
    }
    
    var bclHandlers = {
        rev: function (command) {
            retval.rev = command;
        },
        global: function (command, chunk) {
            chunk.unshift(command);
            retval.global = chunk;
        },
        preset: function (command, chunk) {
            retval.temporaryPreset.presetInfo = chunk;
            _.each(chunk,
                   function (line) {
                       line.replace(/^ *\.name +' *([^ ].+?) *' *(|;.*)$/,
                                    function (match, presetName) {
                                        retval.temporaryPreset.name = presetName;
                                    });
                   });
        },
        encoder: parseControl,
        button: parseControl,
        store: function (command) {
            if (command.replace(/^\$store *([0-9]+)/,
                                function (match, presetNumber) {
                                    retval.presets[presetNumber - 1] = retval.temporaryPreset;
                                    retval.temporaryPreset = { controls: {} };
                                }) == command) {
                console.log('error parsing "' + command + '"');
            }
        },
        end: function () {
        }
    };

    var currentCommand;
    var currentChunk;

    _.each(string.split(/\n/),
           function (line) {
               if (line.match(/^\$[a-z]+/)) {
                   if (currentCommand) {
                       if (bclHandlers[currentCommand]) {
                           bclHandlers[currentCommand](currentChunk.shift(), currentChunk);
                       } else {
                           console.log('unsupported BCL command: "' + currentCommand + '"');
                       }
                   }
                   currentCommand = line.replace(/\$([a-z]+).*/, "$1");
                   currentChunk = [ line ];
               } else {
                   currentChunk.push(line);
               }
           });

    return retval;
}

exports.parseBCL = parseBCL;

function serializeBCL (parsedBCL) {
    var retval = parsedBCL.rev + "\n";

    function addChunk(chunk) {
        retval += chunk.join("\n") + "\n";
    }

    addChunk(parsedBCL.global);

    function addPreset(preset) {
        retval += "$preset\n";
        addChunk(preset.presetInfo);
        _.each(['encoder', 'button'],
               function (type) {
                   _.each(_.range(1, 65),
                          function (controlId) {
                              var control = preset.controls[type + controlId];
                              if (control) {
                                  retval += "$" + type + " " + controlId;
                                  if (control.name) {
                                      retval += " ;" + control.name;
                                  }
                                  retval += "\n";
                                  addChunk(control.bcl);
                              }
                          });
               });
    }

    _.each(_.range(32), function (presetId) {
        var preset = parsedBCL.presets[presetId];
        if (preset) {
            addPreset(preset);
            retval += "$store " + (presetId + 1) + "\n";
        }
    });

    if (parsedBCL.temporaryPreset.presetInfo.length) {
        addPreset(parsedBCL.temporaryPreset);
    }

    retval += "$end\n";

    return retval;
}

exports.serializeBCL = serializeBCL;

function sysexToBcl(buf) {

    function decodeOneLine(buf) {
        if (buf[0] != 0xf0
            || buf[1] != 0x00
            || buf[2] != 0x20
            || buf[3] != 0x32) {
            throw "not a Behringer sysex message";
        }
        if (buf[6] == 0x20) {
            return buf.slice(9, buf.length);
        }
    }

    var response = '';
    for (var i = 0; i < buf.length; ) {
        if (buf[i] != 0xf0) {
            throw "expected sysex begin";
        }
        var j;
        for (j = i; buf[j] != 0xf7; j++)
            ;
        response += decodeOneLine(buf.slice(i, j)) + "\n";
        i = j + 1;
    }
    return response;
}

exports.sysexToBcl = sysexToBcl;

function readSysexFile(filename)
{
    return sysexToBcl(fs.readFileSync(filename));
}

exports.readSysexFile = readSysexFile;

function bclToSysex(bclText) {
    var lines = bclText.split("\n");
    var newlineTerminated = false;
    if (bclText[bclText.length - 1] == "\n") {
        lines.pop();
        newlineTerminated = true;
    }

    // Allocate a buffer - The length is determined by the
    // number of bytes in the string representing the BCL
    // data plus 9 bytes per line to accommodate for the
    // sysex header.
    var buf = new Buffer(bclText.length + (newlineTerminated ? 0 : 1) + lines.length * 9);

    var p = 0;                 // output pointer in buffer
    var lineNumber = 0;        // BCL line number

    function encodeOneLine(line) {
        buf[p++] = 0xf0;
        buf[p++] = 0x00;
        buf[p++] = 0x20;
        buf[p++] = 0x32;
        buf[p++] = 0x00;                     // device id 1, for now
        buf[p++] = 0x15;                     // model -> bcr2000
        buf[p++] = 0x20;                     // BCL message
        buf[p++] = (lineNumber >> 7) & 0x7f; // line number MSB
        buf[p++] = lineNumber & 0x7f;        // line number LSB
        p += buf.write(line, p, 'binary');
        buf[p++] = 0xf7;
        lineNumber++;
    }

    _.each(lines, encodeOneLine);

    return buf;
}

exports.bclToSysex = bclToSysex;

function writeSysexFile(filename, bclText) {
    fs.writeFileSync(filename, bclToSysex(bclText), 'binary');
}

exports.writeSysexFile = writeSysexFile;

// Definition of BCR2000 sysex messages

var sysexRequest = {
    selectPreset: 'f0 0 20 32 0 15 22',
    requestData: 'f0 0 20 32 0 15 40',
    sendBclMessage: 'f0 0 20 32 0 15 20'
};

exports.sysexRequest = sysexRequest;

