// Load the C++ extension, extend it by some convenience functions

var MIDI = require('../build/default/MIDI.node');

for (var i in MIDI) {
    exports[i] = MIDI[i];
}

function messageToString(message) {
    var asString = '';
    for (var j = 0; j < message.length; j++) {
        if (j > 0) {
            asString += ' ';
        }
        asString += message[j].toString(16);
    }
    return asString;
}

exports.messageToString = messageToString;

MIDI.MIDIOutput.prototype.sendNote = function (note, velocity, time) {
    this.send([ 0x90 + (this.channel || 0), note, velocity ],
             time);
}

MIDI.MIDIInput.prototype.recvText = function(callback) {
    this.recv(function (midiInput, data) {
        var stringData = [];
        for (var i in data) {
            stringData.push(messageToString(data[i]));
        }
        callback(midiInput, stringData);
    });
}

function generateEvents(midiInput, messages, error)
{
    if (error) {
        midiInput.emit('error', error);
        return;
    }
    for (var i in messages) {
        var message = messages[i];
        var channel = (message[0] & 0x0f) + 1;
        switch (message[0] & 0xf0) {
        case 0x80:
            midiInput.emit('noteOff', message[1], message[2], channel);
            break;
        case 0x90:
            midiInput.emit('noteOn',  message[1], message[2], channel);
            break;
        case 0xA0:
            midiInput.emit('polyphonicKeyPressure',  message[1], message[2], channel);
            break;
        case 0xB0:
            midiInput.emit('controlChange',  message[1], message[2], channel);
            break;
        case 0xC0:
            midiInput.emit('programChange', message[1], channel);
            break;
        case 0xD0:
            midiInput.emit('channelPressure', message[1], channel);
            break;
        case 0xE0:
            midiInput.emit('pitchWheelChange',  message[1], message[2], channel);
            break;
        case 0xF0:
            switch (message[0] & 0x0f) {
            // system common messages
            case 0x00:
                midiInput.emit('sysex', message);
                break;
            case 0x01:
                midiInput.emit('midiTimeCode', message[1]);
                break;
            case 0x02:
                midiInput.emit('songPositionPointer', message[1], message[2]);
                break;
            case 0x03:
                midiInput.emit('songSelect', message[1]);
                break;
            case 0x04:
            case 0x05:
                console.log("unexpected midi message code 0x" + message[0].toString(16));
                break;
            case 0x06:
                midiInput.emit('tuneRequest');
                break;
            case 0x07:
                console.log("unexpected end of sysex byte at the beginning of a message");
                break;
            // system real time messages
            case 0x08:
                midiInput.emit('timingClock');
                break;
            case 0x09:
                midiInput.emit('tick');
                break;
            case 0x0A:
                midiInput.emit('start');
                break;
            case 0x0B:
                midiInput.emit('continue');
                break;
            case 0x0C:
                midiInput.emit('stop');
                break;
            case 0x0D:
                console.log("unexpected system real time message 0x" + message[0].toString(16));
                break;
            case 0x0E:
                midiInput.emit('activeSensing');
                break;
            case 0x0F:
                midiInput.emit('reset');
            }
            break;
        default:
            console.log("illegal MIDI message status code 0x" + message[0].toString(16));
        }
    }
            
    midiInput.recv(arguments.callee);
}

// PortMIDI Filter bit mask definitions - A set bit means that the corresponding messages are filtered
// Translated from portmidi.h
var filterBits = {
    activeSensing:         (1 << 0x0e),
    sysex:                 (1 << 0x00),
    timingClock:           (1 << 0x08),
    start:                 (1 << 0x0a),
    stop:                  (1 << 0x0c),
    continue:              (1 << 0x0b),
    tick:                  (1 << 0x09),
    reset:                 (1 << 0x0f),
    noteOn:                (1 << 0x19),
    noteOff:               (1 << 0x18),
    channelPressure:       (1 << 0x1d),
    polyphonicKeyPressure: (1 << 0x1a),
    programChange:         (1 << 0x1c),
    controlChange:         (1 << 0x1b),
    pitchWheelChange:      (1 << 0x1e),
    midiTimeCode:          (1 << 0x01),
    songPositionPointer:   (1 << 0x02),
    songSelect:            (1 << 0x03),
    tuneRequest:           (1 << 0x06)
};

// arguments to listen are channel numbers to filter by
MIDI.MIDIInput.prototype.listen = function()
{
    if (!this.listening) {
        this.listening = true;

        this.currentFilter = 0x7fffffff;

        (function (midiInput) {
            midiInput.on('newListener', function (type, listener) {
                // If event being listened for is a MIDI message event
                if (filterBits[type]) {
                    // ... reset the filter bit corresponding to the event type in the MIDI listener
                    midiInput.currentFilter &= ~filterBits[type];
                    midiInput.setFilters(midiInput.channelMask, midiInput.currentFilter);
                }
            });
        })(this);

        this.recv(generateEvents);
    }
    if (arguments.length == 0) {
        this.channelMask = 0xffff;
    } else {
        this.channelMask = 0;
        for (var i = 0; i < arguments.length; i++) {
            this.channelMask |= 1 << (arguments[i] - 1);
        }
    }
    this.setFilters(this.channelMask, this.currentFilter);
}