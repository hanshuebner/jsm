// Load the C++ extension, extend it by some convenience functions

var MIDI = require('../build/default/MIDI.node');
var _ = require('underscore');

for (var i in MIDI) {
    exports[i] = MIDI[i];
}

// MIDI message definitions

// The filterBit key defines PortMIDI Filter bit mask definitions - A
// set bit means that the corresponding messages are filtered
// Translated from portmidi.h.

// The arguments key defines how many arguments the message type has.

var midiMessageDefs = {
    noteOff:               { statusCode: 0x80, filterBit: (1 << 0x18) },
    noteOn:                { statusCode: 0x90, filterBit: (1 << 0x19) },
    polyphonicKeyPressure: { statusCode: 0xa0, filterBit: (1 << 0x1a), arguments: 2 },
    controlChange:         { statusCode: 0xb0, filterBit: (1 << 0x1b), arguments: 2 },
    programChange:         { statusCode: 0xc0, filterBit: (1 << 0x1c), arguments: 1 },
    channelPressure:       { statusCode: 0xd0, filterBit: (1 << 0x1d), arguments: 1 },
    pitchWheelChange:      { statusCode: 0xe0, filterBit: (1 << 0x1e), arguments: 2 },
    sysex:                 { statusCode: 0xf0, filterBit: (1 << 0x00) },
    midiTimeCode:          { statusCode: 0xf1, filterBit: (1 << 0x01), arguments: 1 },
    songPositionPointer:   { statusCode: 0xf2, filterBit: (1 << 0x02), arguments: 2 },
    songSelect:            { statusCode: 0xf3, filterBit: (1 << 0x03), arguments: 1 },
    tuneRequest:           { statusCode: 0xf6, filterBit: (1 << 0x06), arguments: 0 },
    timingClock:           { statusCode: 0xf8, filterBit: (1 << 0x08), arguments: 0 },
    tick:                  { statusCode: 0xf9, filterBit: (1 << 0x09), arguments: 0 },
    start:                 { statusCode: 0xfa, filterBit: (1 << 0x0a), arguments: 0 },
    stop:                  { statusCode: 0xfb, filterBit: (1 << 0x0c), arguments: 0 },
    continue:              { statusCode: 0xfc, filterBit: (1 << 0x0b), arguments: 0 },
    activeSensing:         { statusCode: 0xfe, filterBit: (1 << 0x0e), arguments: 0 },
    reset:                 { statusCode: 0xff, filterBit: (1 << 0x0f), arguments: 0 }
};

function messageToString(message) {
    var asString = '';
    for (var j = 0; j < message.length; j++) {
        if (j > 0) {
            asString += ' ';
        }
        asString += message[j].toString(16);
    }
    return asString;
}

exports.messageToString = messageToString;

function makeStatusCode(messageType, channel) {
    var statusCode = midiMessageDefs[messageType].statusCode;
    var channel = channel ? (channel - 1) : 0;
    return statusCode | (((statusCode & 0xf0) != 0xf0) ? channel : 0);
}

// Generate a convenience function for the messageType given
function makeHandler(messageType) {
    switch (midiMessageDefs[messageType].arguments) {
    case 0:
        return function (time) {
            if (arguments.length > 1) {
                throw "unexpected number of arguments to " + messageType;
            }
            this.send([ makeStatusCode(messageType, this.channel) ],
                      time);
        }
        break;
    case 1:
        return function (arg, time) {
            if (arguments.length < 1 || arguments.length > 2) {
                throw "unexpected number of arguments to " + messageType;
            }
            this.send([ makeStatusCode(messageType, this.channel), arg ],
                      time);
        }
        break;
    case 2:
        return function (arg1, arg2, time) {
            if (arguments.length < 2 || arguments.length > 3) {
                throw "unexpected number of arguments to " + messageType;
            }
            this.send([ makeStatusCode(messageType, this.channel), arg1, arg2 ],
                      time);
        }
        break;
    }
}

// Generate convenience functions for every defined MIDI message
for (var messageType in midiMessageDefs) {
    if (midiMessageDefs[messageType].arguments != undefined) {
        MIDI.MIDIOutput.prototype[messageType] = makeHandler(messageType);
    }
}

MIDI.MIDIOutput.prototype.sysex = function (data, time) {
    if (data[0] != 0xf0 || data[data.length - 1] != 0xf7) {
        throw "invalid sysex message, must start with 0xf0 and end with 0xf7";
    }
    this.send(data, time);
}

var noteNames = [ 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B' ];
var noteNameToOffset = {};
for (var i in noteNames) {
    noteNameToOffset[noteNames[i]] = parseInt(i);
}

function noteToPitch(noteName) {
    var pitch;
    noteName.replace(/^([A-Ga-g]#?)(-?[0-9])$/, function (dummy, name, octave) {
        pitch = (12 * octave) + noteNameToOffset[name.toUpperCase()] + 24;
    });
    if (pitch == undefined) {
        throw "invalid note name " + noteName;
    }
    return pitch;
}

function pitchToNote(pitch) {
    return noteNames[pitch % 12] + (Math.floor(pitch / 12) - 2).toString();
}

exports.noteToPitch = noteToPitch;
exports.pitchToNote = pitchToNote;

function makeNoteMessageFunction(messageType) {
    return function (note, velocity, time) {
        var parsedNote = parseInt(note);
        if (isNaN(parsedNote)) {
            parsedNote = noteToPitch(note);
        }
        this.send([ makeStatusCode(messageType, this.channel), parsedNote, velocity ], time);
    }
}

MIDI.MIDIOutput.prototype.noteOn = makeNoteMessageFunction('noteOn');
MIDI.MIDIOutput.prototype.noteOff = makeNoteMessageFunction('noteOff');

MIDI.MIDIOutput.prototype.nrpn = function (parameter, value, short) {

    this.controlChange(0x63, parameter >> 7);
    this.controlChange(0x62, parameter & 0x7f);
    if (short) {
        if (value > 0x7f) {
            throw "cannot send short nrpn for values > 0x7f";
        }
        this.controlChange(0x06, value)
    } else {
        if (value > 0x7f) {
            this.controlChange(0x06, value >> 7);
        }
        this.controlChange(0x26, value & 0x7f);
    }
}

MIDI.MIDIInput.prototype.recvText = function(callback) {
    this.recv(function (midiInput, data) {
        var stringData = [];
        for (var i in data) {
            stringData.push(messageToString(data[i]));
        }
        callback(midiInput, stringData);
    });
}

function generateEvents(midiInput, messages, error)
{
    if (error) {
        midiInput.emit('error', error);
        return;
    }
    for (var i in messages) {
        var message = messages[i];
        var channel = (message[0] & 0x0f) + 1;
        switch (message[0] & 0xf0) {
        case 0x80:
            midiInput.emit('noteOff', message[1], message[2], channel);
            break;
        case 0x90:
            midiInput.emit('noteOn',  message[1], message[2], channel);
            break;
        case 0xA0:
            midiInput.emit('polyphonicKeyPressure',  message[1], message[2], channel);
            break;
        case 0xB0:
            midiInput.emit('controlChange',  message[1], message[2], channel);
            break;
        case 0xC0:
            midiInput.emit('programChange', message[1], channel);
            break;
        case 0xD0:
            midiInput.emit('channelPressure', message[1], channel);
            break;
        case 0xE0:
            midiInput.emit('pitchWheelChange',  message[1], message[2], channel);
            break;
        case 0xF0:
            switch (message[0] & 0x0f) {
            // system common messages
            case 0x00:
                midiInput.emit('sysex', message);
                break;
            case 0x01:
                midiInput.emit('midiTimeCode', message[1]);
                break;
            case 0x02:
                midiInput.emit('songPositionPointer', message[1], message[2]);
                break;
            case 0x03:
                midiInput.emit('songSelect', message[1]);
                break;
            case 0x04:
            case 0x05:
                console.log("unexpected midi message code 0x" + message[0].toString(16));
                break;
            case 0x06:
                midiInput.emit('tuneRequest');
                break;
            case 0x07:
                console.log("unexpected end of sysex byte at the beginning of a message");
                break;
            // system real time messages
            case 0x08:
                midiInput.emit('timingClock');
                break;
            case 0x09:
                midiInput.emit('tick');
                break;
            case 0x0A:
                midiInput.emit('start');
                break;
            case 0x0B:
                midiInput.emit('continue');
                break;
            case 0x0C:
                midiInput.emit('stop');
                break;
            case 0x0D:
                console.log("unexpected system real time message 0x" + message[0].toString(16));
                break;
            case 0x0E:
                midiInput.emit('activeSensing');
                break;
            case 0x0F:
                midiInput.emit('reset');
            }
            break;
        default:
            console.log("illegal MIDI message status code 0x" + message[0].toString(16));
        }
    }
            
    midiInput.recv(arguments.callee);
}

function NRPN(parameters) {
    this.is14Bit = !parameters.nrpnShortValues;
    this.parameterMsb = 0;
    this.parameterLsb = 0;
    this.valueMsb = 0;
    this.valueLsb = 0;
}

NRPN.prototype.parameter = function () {
    return this.parameterMsb << 7 | this.parameterLsb;
}

NRPN.prototype.value = function () {
    if (this.is14Bit) {
        return this.valueMsb << 7 | this.valueLsb;
    } else {
        return this.valueMsb;
    }
}

NRPN.prototype.increment = function (delta) {
    if (this.is14Bit) {
        var value = this.value() + delta;
        if (value < 0) {
            value = 0;
        } else if (value > 0x3fff) {
            value = 0x3fff;
        }
        this.valueLsb = value & 0x7f;
        this.valueMsb = (value >> 7);
    } else {
        this.valueMsb += delta;
        if (this.valueMsb < 0) {
            this.valueMsb = 0;
        } else if (this.valueMsb > 0x7f) {
            this.valueMsb = 0x7f;
        }
    }
}

NRPN.prototype.clearValue = function () {
    this.valueMsb = 0;
    this.valueLsb = 0;
}

NRPN.prototype.clear = function () {
    this.parameterMsb = 0;
    this.parameterLsb = 0;
    this.clearValue();
}

function processNrpn(controllerNumber, value, channel) {
    // console.log('controllerNumber', controllerNumber.toString(16), 'value', value, 'channel', channel, 'nrpn', this.nrpn);
    var nrpn = this.nrpn;
    switch (controllerNumber) {
    case 0x63:
        nrpn.parameterMsb = value;
        nrpn.clearValue();
        break;
    case 0x62:
        nrpn.parameterLsb = value;
        if (nrpn.parameter() == 0x3fff) {
            this.nrpn.clear();
        } else {
            nrpn.clearValue();
        }
        break;
    case 0x06:
        nrpn.valueMsb = value;
        if (!nrpn.is14Bit) {
            this.emit('nrpn', nrpn.parameter(), nrpn.value());
        }
        break;
    case 0x26:
        nrpn.valueLsb = value;
        // If LSB value is received in 14 bit mode, it is just ignored.
        if (nrpn.is14Bit) {
            this.emit('nrpn', nrpn.parameter(), nrpn.value());
        }
        break;
    case 0x60:
        nrpn.increment(value);
        this.emit('nrpn', nrpn.parameter(), nrpn.value());
        break;
    case 0x61:
        nrpn.increment(-value);
        this.emit('nrpn', nrpn.parameter(), nrpn.value());
        break;
    }
}

// arguments to listen are channel numbers to filter by
MIDI.MIDIInput.prototype.listen = function(parameters)
{
    parameters = parameters || {};
    
    if (!this.listening) {
        this.listening = true;

        this.currentFilter = 0x7fffffff;

        (function (midiInput) {
            midiInput.on('newListener', function (type, listener) {
                // If event being listened for is a MIDI message event
                if (midiMessageDefs[type] && midiMessageDefs[type].filterBit) {
                    // ... reset the filter bit corresponding to the event type in the MIDI listener
                    midiInput.currentFilter &= ~midiMessageDefs[type].filterBit;
                    midiInput.setFilters(midiInput.channelMask, midiInput.currentFilter);
                }
                // If listener is interested in the nrpn event, enable nrpn processing
                if (type == 'nrpn' && !midiInput.nrpn) {
                    midiInput.nrpn = new NRPN(parameters);
                    midiInput.on('controlChange', _.bind(processNrpn, midiInput));
                }
            });
        })(this);

        this.recv(generateEvents);
    }
    if (arguments.length == 0) {
        this.channelMask = 0xffff;
    } else {
        this.channelMask = 0;
        for (var i = 0; i < arguments.length; i++) {
            this.channelMask |= 1 << (arguments[i] - 1);
        }
    }
    this.setFilters(this.channelMask, this.currentFilter);
}